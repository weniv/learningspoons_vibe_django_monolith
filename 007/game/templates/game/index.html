<!-- templates/game/index.html (전체 교체) -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>요리 아이템 수집 게임 (멀티플레이어)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            min-width: 200px;
        }
        #players-list {
            margin-top: 10px;
            font-size: 12px;
        }
        .player-info {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>요리 아이템 수집 게임</h2>
        <p>이동: WASD 키</p>
        <p>내 점수: <span id="score">0</span></p>
        <div id="players-list">
            <strong>접속한 플레이어:</strong>
            <div id="player-count">0명</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // WebSocket 연결
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/game/`;
        const socket = new WebSocket(wsUrl);

        // Three.js 기본 설정
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // 하늘색 배경
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 조명 추가
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 바닥 생성 (격자무늬)
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            roughness: 0.8
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // 격자선 추가
        const gridHelper = new THREE.GridHelper(20, 20, 0x000000, 0x000000);
        gridHelper.material.opacity = 0.2;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // 다른 플레이어들을 저장하는 객체
        const otherPlayers = {};

        // 내 플레이어 색상 (랜덤)
        const myColor = Math.random() * 0xffffff;

        // 내 플레이어 생성
        const myPlayerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const myPlayerMaterial = new THREE.MeshStandardMaterial({ color: myColor });
        const myPlayer = new THREE.Mesh(myPlayerGeometry, myPlayerMaterial);
        myPlayer.position.set(0, 0.5, 0);
        myPlayer.castShadow = true;
        scene.add(myPlayer);

        // 플레이어 이름 표시 (선택사항)
        function createPlayerNameTag(name) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.font = 'Bold 40px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.fillText(name, 128, 45);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.y = 1.5;
            return sprite;
        }

        const myNameTag = createPlayerNameTag('나');
        myPlayer.add(myNameTag);

        // 아이템 생성
        const items = [];
        const itemsData = [];

        function createItem(id, x, z) {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.3
            });
            const item = new THREE.Mesh(geometry, material);
            item.position.set(x, 0.3, z);
            item.userData.id = id;
            scene.add(item);
            items.push(item);
            itemsData.push({ id, x, z });
        }

        // 초기 아이템 10개 생성
        for (let i = 0; i < 10; i++) {
            const x = Math.random() * 18 - 9;
            const z = Math.random() * 18 - 9;
            createItem(i, x, z);
        }

        // 카메라 위치
        camera.position.set(0, 15, 15);
        camera.lookAt(0, 0, 0);

        // 키보드 입력
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        let score = 0;
        let lastUpdateTime = 0;
        const updateInterval = 50; // 50ms마다 위치 전송

        // WebSocket 메시지 처리
        socket.onopen = () => {
            console.log('WebSocket 연결됨');
        };

        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'player_position') {
                // 다른 플레이어의 위치 업데이트
                if (data.player_id !== socket.url) {
                    if (!otherPlayers[data.player_id]) {
                        // 새 플레이어 생성
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshStandardMaterial({
                            color: parseInt(data.color) || 0xff0000
                        });
                        const player = new THREE.Mesh(geometry, material);
                        player.position.set(data.x, 0.5, data.z);
                        player.castShadow = true;

                        const nameTag = createPlayerNameTag('플레이어');
                        player.add(nameTag);

                        scene.add(player);
                        otherPlayers[data.player_id] = player;
                    } else {
                        // 기존 플레이어 위치 업데이트 (부드러운 이동)
                        otherPlayers[data.player_id].position.x = data.x;
                        otherPlayers[data.player_id].position.z = data.z;
                    }
                }
            } else if (data.type === 'player_joined') {
                console.log('플레이어 참가:', data.player_id);
                updatePlayerCount();
            } else if (data.type === 'player_left') {
                // 플레이어가 나갔을 때
                if (otherPlayers[data.player_id]) {
                    scene.remove(otherPlayers[data.player_id]);
                    delete otherPlayers[data.player_id];
                }
                updatePlayerCount();
            } else if (data.type === 'item_removed') {
                // 아이템이 수집되었을 때
                const itemIndex = items.findIndex(item => item.userData.id === data.item_id);
                if (itemIndex !== -1) {
                    scene.remove(items[itemIndex]);
                    items.splice(itemIndex, 1);

                    // 새 아이템 생성
                    const newId = Date.now();
                    const x = Math.random() * 18 - 9;
                    const z = Math.random() * 18 - 9;
                    createItem(newId, x, z);
                }
            }
        };

        socket.onerror = (error) => {
            console.error('WebSocket 에러:', error);
        };

        socket.onclose = () => {
            console.log('WebSocket 연결 종료');
        };

        function updatePlayerCount() {
            const count = Object.keys(otherPlayers).length + 1; // 자신 포함
            document.getElementById('player-count').textContent = `${count}명`;
        }

        // 게임 루프
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            let moved = false;

            // 플레이어 이동
            const speed = 0.1;
            const oldX = myPlayer.position.x;
            const oldZ = myPlayer.position.z;

            if (keys['w']) { myPlayer.position.z -= speed; moved = true; }
            if (keys['s']) { myPlayer.position.z += speed; moved = true; }
            if (keys['a']) { myPlayer.position.x -= speed; moved = true; }
            if (keys['d']) { myPlayer.position.x += speed; moved = true; }

            // 경계 체크
            myPlayer.position.x = Math.max(-9.5, Math.min(9.5, myPlayer.position.x));
            myPlayer.position.z = Math.max(-9.5, Math.min(9.5, myPlayer.position.z));

            // 위치가 변경되었고 일정 시간이 지났으면 서버에 전송
            if (moved && currentTime - lastUpdateTime > updateInterval) {
                socket.send(JSON.stringify({
                    type: 'player_move',
                    x: myPlayer.position.x,
                    z: myPlayer.position.z,
                    color: myColor
                }));
                lastUpdateTime = currentTime;
            }

            // 아이템 충돌 감지
            items.forEach((item, index) => {
                const distance = myPlayer.position.distanceTo(item.position);
                if (distance < 1) {
                    const itemId = item.userData.id;
                    scene.remove(item);
                    items.splice(index, 1);
                    score += 10;
                    document.getElementById('score').textContent = score;

                    // 서버에 아이템 수집 알림
                    socket.send(JSON.stringify({
                        type: 'item_collected',
                        item_id: itemId,
                        score: score
                    }));

                    // 새 아이템 생성
                    const newId = Date.now();
                    const x = Math.random() * 18 - 9;
                    const z = Math.random() * 18 - 9;
                    createItem(newId, x, z);
                }
            });

            // 카메라가 내 플레이어를 따라가도록
            camera.position.x = myPlayer.position.x;
            camera.position.z = myPlayer.position.z + 15;
            camera.lookAt(myPlayer.position.x, 0, myPlayer.position.z);

            renderer.render(scene, camera);
        }

        animate();

        // 화면 크기 변경 대응
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>